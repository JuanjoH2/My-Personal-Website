<section id="code">
    <div id="codeDiv" class="subtitleDiv">
        <h2>Code</h2>
        <button onclick="window.location.href='/code'"> </button>
    </div>

    <!-- Container for the binary rain effect. It sits behind the code box. -->
    <div id="binaryRainContainer"></div>
</section>

<script is:inline>
    // Wait for the entire DOM to load before trying to access elements
    document.addEventListener("DOMContentLoaded", () => {
        const container = document.getElementById("binaryRainContainer");
        const codeDiv = document.getElementById("codeDiv");

        if (!container || !codeDiv) {
            console.error("Required DOM elements not found for animation.");
            return;
        }

        let intervalId = null;

        // Binary digits
        const WORDS = ["1", "0"];

        // High spawn rate for a dense rain effect
        const spawnRate = 50;

        function spawnBinaryDrop() {
            const randomIndex = Math.floor(Math.random() * WORDS.length);
            const word = WORDS[randomIndex];

            const span = document.createElement("span");
            // Consistent class name
            span.className = "binary-drop";
            span.textContent = word;

            // --- MATRIX RAIN EFFECT PROPERTIES ---

            // Random horizontal start position (0% to 100%)
            const randomXStart = Math.random() * 100;

            // Fall distance in VH units: from its initial off-screen position, it must fall
            // at least 100vh to pass the bottom edge of the section.
            const fallDistanceVh = Math.random() * 50 + 100; // 100vh to 150vh

            // Random duration (fall speed)
            const randomDuration = Math.random() * 3 + 2; // 2.0s to 5.0s

            // Random size for depth/variation
            const randomSize = Math.floor(Math.random() * 14) + 12; // 12px to 26px

            // Apply dynamic CSS for starting position and size
            span.style.left = `${randomXStart}%`;
            span.style.fontSize = `${randomSize}px`;
            span.style.transitionDuration = `${randomDuration}s`;

            // Optional: brighter color for distinction
            if (Math.random() < 0.1) {
                span.style.color = "#00ffff";
                span.style.opacity = "1";
            }

            // Add to DOM
            container.appendChild(span);

            // Trigger the transition after the element is in the DOM
            requestAnimationFrame(() => {
                // The transition happens between the CSS default (translateY(-100%)) and this target value
                span.style.transform = `translateY(${fallDistanceVh}vh)`;
            });

            // Clean up: Remove the element after its animation is complete
            setTimeout(
                () => {
                    span.remove();
                },
                randomDuration * 1000 + 100,
            );
        }

        function startRain() {
            // Only start if it's not already running
            if (intervalId !== null) return;
            intervalId = setInterval(spawnBinaryDrop, spawnRate);
        }

        function stopRain() {
            if (intervalId !== null) {
                clearInterval(intervalId);
                intervalId = null;
            }
        }

        // --- Event Handlers ---

        // 1. Desktop: Mouse Events
        codeDiv.addEventListener("mouseenter", startRain);
        codeDiv.addEventListener("mouseleave", stopRain);

        // 2. Mobile: Touch Events (The Fix)
        // Note: For touch, a tap initiates both the rain AND the button's navigation.
        // We start the rain on 'touchstart' and let the page navigation stop it.
        // If the user taps the background of codeDiv, the rain will start and persist
        // until they tap somewhere else on the page (though we don't have a specific
        // 'stop' for that case, it often clears itself).
        codeDiv.addEventListener("touchstart", startRain, { passive: true });

        // Use 'touchend' to stop the rain if they lift their finger outside the button
        // and aren't navigating. (Passive is important for touch event performance).
        codeDiv.addEventListener("touchend", stopRain);
        codeDiv.addEventListener("touchcancel", stopRain);

        // 3. Prevent Rain when the button is actively clicked/tapped (optional cleanup)
        // You could add logic here to *only* show the rain if the button wasn't the target.
        // For now, the existing navigation prevents long rain, which is usually fine.
    });
</script>

<style is:global>
    /*
     * LOCAL STYLES (is:global added to prevent Astro scoping, allowing JS-created elements to be styled)
     */
    #code {
        /* overflow: hidden is critical to hide the rain when it falls past the section boundary */
        overflow: hidden;
        position: relative;
    }

    #codeDiv {
        position: relative;
        z-index: 6;
        /* Make sure this area is tappable for the effect */
        touch-action: manipulation;
    }

    #binaryRainContainer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        /* Ensure the container is behind the 'Code' box */
        z-index: 0;
    }

    /* ðŸ’¥ HIGHLY SPECIFIC SELECTOR ðŸ’¥ 
       This CSS will now apply globally, correctly styling the dynamic spans. */
    #binaryRainContainer .binary-drop {
        position: absolute;
        z-index: 5;

        /* START POSITION: This is the crucial configuration */
        top: 0;
        left: 0;

        /* ðŸ’¡ THE CRITICAL FIX: Start 100% of its own height UP and OFF-SCREEN. */
        transform: translateY(-100%);

        /* Base styles */
        font-weight: bold;
        white-space: nowrap;
        color: white; /* Classic Matrix green */
        opacity: 0.8;

        /* Ensure the transition property is explicitly defined */
        transition:
            transform linear,
            /* Ensures constant falling speed */ color 0.5s ease-out;
    }
</style>
